#!/usr/bin/env python
"""Cron management classes."""


import threading
import time

import logging

from grr.lib import access_control
from grr.lib import aff4
from grr.lib import flow
from grr.lib import rdfvalue
from grr.lib import registry
from grr.lib import utils

from grr.lib.flows.cron import system


CRON_MANAGER = None


class CronManager(object):
  """CronManager is used to schedule/terminate cron jobs."""

  CRON_JOBS_PATH = rdfvalue.RDFURN("aff4:/cron")

  def ScheduleFlow(self, flow_name, flow_args=None,
                   frequency=rdfvalue.Duration("1d"), allow_overruns=False,
                   job_name=None, token=None):
    """Creates a cron job that runs given flow with a given frequency.

    Args:
      flow_name: Name of the flow to be executed periodically.
      flow_args: Dictionary of arguments that will be passed to the flow each
                 time.
      frequency: rdfvalue.Duration between the flow runs.
      allow_overruns: If True, the flow will be started even if previous
                      iteration hasn't finished yet.
      job_name: Use this job_name instead of an autogenerated unique name (used
                for system cron jobs - we want them to have well-defined
                persistent name).
      token: Security token used for data store access.

    Returns:
      URN of the cron job created.
    """
    if not job_name:
      uid = utils.PRNG.GetUShort()
      job_name = "%s_%s" % (flow_name, uid)

    cron_job_urn = self.CRON_JOBS_PATH.Add(job_name)
    cron_job = aff4.FACTORY.Create(cron_job_urn, "CronJob", token=token)

    cron_job.Set(cron_job.Schema.FLOW_NAME(flow_name))
    cron_job.Set(cron_job.Schema.FLOW_ARGS(flow_args or {}))
    cron_job.Set(cron_job.Schema.FREQUENCY(frequency))
    cron_job.Set(cron_job.Schema.ALLOW_OVERRUNS(allow_overruns))

    cron_job.Close()

    return cron_job_urn

  def ListJobs(self, token=None):
    """Returns a generator of URNs of all currently running cron jobs."""
    return aff4.FACTORY.Open(self.CRON_JOBS_PATH, token=token).ListChildren()

  def DeleteJob(self, job_urn, token=None):
    """Deletes cron job with the given URN."""
    aff4.FACTORY.Delete(job_urn, token=token)

  def RunOnce(self, token=None):
    """Tries to lock and run every cron job."""
    for cron_job_urn in self.ListJobs(token=token):
      try:

        with aff4.FACTORY.OpenWithLock(
            cron_job_urn, blocking=False,
            lease_time=3600, token=token) as cron_job:
          try:
            logging.info("Running cron job: %s", cron_job.urn)
            cron_job.Run()
          except Exception as e:  # pylint: disable=broad-except
            logging.error("Error processing cron job %s: %s", cron_job.urn, e)

      except aff4.LockError:
        pass


class CronManagerInit(registry.InitHook):
  """Initialize the cron manager."""

  pre = ["DataStoreInit"]

  def Run(self):
    """Initialize the cron manager."""
    global CRON_MANAGER  # pylint: disable=W0603

    CRON_MANAGER = CronManager()


def ScheduleSystemCronFlows(token=None):
  for name, cls in flow.GRRFlow.classes.items():
    if aff4.issubclass(cls, system.SystemCronFlow):
      CRON_MANAGER.ScheduleFlow(name, frequency=cls.frequency, job_name=name,
                                token=token)


class CronWorker(object):
  """CronWorker runs a thread that periodically executed cron jobs."""

  def __init__(self, thread_name="grr_cron", sleep=60*5):
    self.thread_name = thread_name
    self.sleep = sleep

    self.token = access_control.ACLToken("GRRCron", "Implied.")
    self.token.supervisor = True

  def _RunLoop(self):
    ScheduleSystemCronFlows(token=self.token)

    while True:
      try:
        CRON_MANAGER.RunOnce(token=self.token)
      except Exception as e:  # pylint: disable=broad-except
        logging.error("CronWorker uncaught exception: %s", e)

      time.sleep(self.sleep)

  def Run(self):
    """Runs a working thread and waits for it to finish."""
    self.RunAsync().join()

  def RunAsync(self):
    """Runs a working thread and returns immediately."""
    self.running_thread = threading.Thread(name=self.thread_name,
                                           target=self._RunLoop)
    self.running_thread.daemon = True
    self.running_thread.start()
    return self.running_thread
