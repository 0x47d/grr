The GRR Configuration system
============================
:toc2:
:icons:

The GRR configuration system is the main way users can control and customize the
behavior of GRR components. Previous versions of GRR used command line flags to
configure component, however that became unwieldy with a lot of confusing and
often contradictory command line options embedded in various shell scripts. We
decided to replace the configuration system with an ini file based system.

General configuration file structure.
-------------------------------------

The GRR configuration file is based around the concept of an INI file. The file
is broken up into sections, and configuration parameters specific to each
section are given with that. For example:

[source,ini]
--------------------------------------------------------------------
[Client]
location = http://www.example.com/

[NannyWindows]
service_key = HKEY_LOCAL_MACHINE\\Software\\GRR
--------------------------------------------------------------------

All configuration parameters in GRR referred to by their section name followed
by a dot followed by the parameter name. For example above we have
Client.location and 'NannyWindows.service_key' defined.


Parameter Typing
----------------

When software is written with the GRR configuration system, it can define
parameters that it is going to use. This declares the sections, the parameter name
and a helpful message. In addition, the parameter's type is also declared. For
example we can find the following code:

[source,python]
--------------------------------------------------------------------
config_lib.DEFINE_float("Client.rss_max", 500,
                        "Maximum memory footprint in MB.")

config_lib.DEFINE_option(type_info.PEMPrivateKey(
    name="Client.private_key",
    description="Client private key in pem format. If not provided this "
    "will be generated by the enrollment process.",
    ))
--------------------------------------------------------------------

The first definition declares the parameter Client.rss_max to be a float, with a
default value of 500.

The second definition is more complex. It defines the Client.private_key
parameter as a PEMPrivateKey type info declaration. This declaration allows the
configuration system itself to verify that the parameter is a valid private key
in PEM format. There is now no need for the code to specifically test for sanity
of the private key. If the user provides an invalid or corrupt PEM encoded key,
it is caught immediately by the config system and the program aborts. For
example the following happens after removing a random character from the
CA.certificate PEM string:

--------------------------------------------------------------------
Traceback (most recent call last):
  File "grr/client/client.py", line 48, in <module>
    conf.StartMain(main)
  File "grr/client/conf.py", line 93, in StartMain
    main([sys.argv[0]])
......
  File "grr/lib/config_lib.py", line 467, in _VerifyParameters
    descriptor.Validate(value)
  File "grr/lib/rdfvalues/crypto.py", line 173, in Validate
    return self.ParseFromString(value)
  File "grr/lib/rdfvalues/crypto.py", line 185, in ParseFromString
    raise type_info.TypeValueError("Certificate %s is invalid." % self.name)
grr.lib.type_info.TypeValueError: Certificate CA.certificate is invalid.
--------------------------------------------------------------------

Since every parameter is defined in advance and has a default value, the config
file does not need to specify every parameter - only those which should be
changed from the default value. In order to see all declared parameters and
their default values, we can issue the --config_help command line flag. This is
analogous to the --help flag:

--------------------------------------------------------------------
Client.location = http://www.example.com/control
   URL of the controlling server.
* Value = http://localhost:8080/control

Client.max_out_queue = 10240000
   Maximum size of the output queue.
* Value = 10240000
--------------------------------------------------------------------

We can see that Client.location has a default value of
http://www.example.com/control, it is used to specify the URL of the controlling
server, and currently (after reading the configuration files), the value is set
to http://localhost:8080/control. We can also see that Client.max_out_queue is
not changed from its default value.


Executable sections.
--------------------

GRR contains many different components, each component having its own
configuration parameters. For example, the Client component refers to the client
binary, the Nanny component is used by the Nanny program etc.

When a main component program is run, it is desirable to apply specific
configuration for it, which may be different from other main components. For
example, the parameter Logging.path describes the filename for log files to be
written to. When running the client we might want this to be different than when
running the server.

We could solve this problem by having multiple configuration files - one for the
client and one for the server. But this can make is hard to manage and
synchronize.

In GRR we have executable sections. When a section is executed, it assigns
configuration directives to other sections, thereby updating their
configuration. For example:

[source,ini]
--------------------------------------------------------------------
[Client]
location = http://www.example.com/

[Logging]
path = /var/log/grr.log                                        # <1>

[NannyWindows]
service_key = HKEY_LOCAL_MACHINE\\Software\\GRR
Logging.path = /var/log/grr_nanny.log                          # <2>
--------------------------------------------------------------------

<1> This configuration parameter specifies the name of the log file that is used
normally.

<2> When the nanny main program is run, it executes its section (called
Nanny). This causes this parameter to assign a different value to the
Logging.path parameter. The overall result is that the nanny program will now log
to a different path than everyone else.


This technique can be used to create a single configuration file, which causes
different behaviors in different components. For example, we can use this to
configure different parameters for different OS versions of the client. For
example the following causes windows clients and Linux clients to talk to
different front ends:

[source,ini]
--------------------------------------------------------------------
[Client]
location = http://www.example.com/

[ClientWindows]
Client.location = http://www.example.com/windows/

[ClientLinux]
Client.location = http://www.example.com/linux/
--------------------------------------------------------------------

In addition to components executing sections, it is possible to specify that
sections be executed from the command line. This allows the same config file to
specify a number of 'roles', which are fairly similar except for some small
number of parameters which differ. For example, one might want to test the
client on a test server prior to deployment:

[source,ini]
--------------------------------------------------------------------
[Client]
location = http://www.example.com/frontend/


[TestClient]
Client.location = http://www.example.com/test_frontend/
--------------------------------------------------------------------

Then launching the client will override the Client's location temporarily:
[source,sh]
--------------------------------------------------------------------
client.py --config_execute TestClient
--------------------------------------------------------------------

Parameter Expansions
--------------------

The GRR configuration file format allows for expansion of configuration
parameters inside other parameters. For example consider the following
configuration file:

[source,ini]
--------------------------------------------------------------------
[Client]
name = GRR

[NannyWindows]
service_name = %(Client.name)service.exe
service_key_hive = HKEY_LOCAL_MACHINE
service_key_path = Software\\%(Client.name)
service_key = %(service_key_hive)\\%(service_key_path)
initial_commandline =
--------------------------------------------------------------------

The expansion sequence '%(parameter_name)' substitutes or expands the parameter
into the string. This allows us to build values automatically based on other
values. For example above, the 'NannyWindows.service_name' will be 'GRRservice.exe' and
the service_key will be set to 'HKEY_LOCAL_MACHINE\Software\GRR'

Expansion is very useful, but sometimes it gets in the way. For example, if we
need to pass literal % escape sequences. Consider the Logging.format parameter
which is actually a python format string:

[source,ini]
--------------------------------------------------------------------
[Logging]
format = \%(levelname\)s \%(module\)s:\%(lineno\)s] \%(message\)s  # <1>
format = %{%(levelname)s %(module)s:%(lineno)s] %(message)s}       # <2>
--------------------------------------------------------------------

<1> This form escapes GRR's special escaping sequence by preceding both opening
and closing sequences with the backslash character.

<2> This variation uses the literal expansion sequence '%{}' to declare the
entire line as a literal string and prevent expansion.

Filtering
---------

The configuration system may be extended to provide additional functionality
accessible from the configuration file. For example consider the following
configuration file:

[source,ini]
--------------------------------------------------------------------
[Logging]
path = %(HOME|env)/grr.log                             # <1>
--------------------------------------------------------------------

<1> This expansion sequence uses the 'env' filter which expands a value from the
environment. In this case the environment variable 'HOME' will be expanded into
the 'Logging.path' parameter to place the log file in the user's home directory.

There are a number of additional interesting filters. The 'file' filter allows
including other files from the filesystem into the configuration file. For
example, some people prefer to keep their certificates in separate files rather
than paste them into the config file:

[source,ini]
--------------------------------------------------------------------
[CA]
certificate = %(/etc/certificates/ca.pem|file)
--------------------------------------------------------------------

It is even possible to nest expansion sequences. For example this retrieves the
client's private key from a location which depends on the client name:

[source,ini]
--------------------------------------------------------------------
[Client]
private_key = %(/etc/grr/client/%(Client.name)/private_key.pem|file)
--------------------------------------------------------------------


Configuration parsers
---------------------

The above describes the GRR configuration system as an INI file and that is the
most commonly used format. However, configuration files are parsed using a
parser implementation which can be switched on demand. Currently there are a few
configuration parser implementations but additional ones can be added.

The windows client implements a registry based configuration parser. This allows
GRR to use the registry instead of a flat file when running on windows. The
registry base parser is selected by using a URL of the form:

[source,sh]
--------------------------------------------------------------------
client.py --config reg://HKEY_LOCAL_MACHINE/Software/GRR
--------------------------------------------------------------------

In future additional parsers may be implemented.
