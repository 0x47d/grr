// Copyright 2012 Google Inc
// All Rights Reserved.
//
// Author: scudette@gmail.com (Michael Cohen)

#ifndef GRR_CLIENT_NANNY_WINDOWS_NANNY_H_
#define GRR_CLIENT_NANNY_WINDOWS_NANNY_H_

// The nanny is a service which runs another child executable, and makes it
// behave. The nanny itself is very simple, hence is it unlikely to leak or
// crash itself, but is used to ensure the more complex child behaves.

// This file implements a Windows-specific ChildController (see description in
// child_controller.h).
#include <windows.h>

#include "grr/client/nanny/child_controller.h"

TCHAR kGrrServiceName[] = TEXT("%(NannyWindows.name)s");
TCHAR kGrrServiceDesc[] = TEXT("%(NannyWindows.description)s");

// A registry key that holds GRR service configuration.
#define GRR_SERVICE_REGISTRY_HIVE %(Registry.Service_Key_Hive)s

const TCHAR* kGrrServiceRegistry = TEXT("%(NannyWindows.service_key_path)s");

// A registry value specifying the child that will be run.
const TCHAR* kGrrServiceBinaryChild = TEXT("%(NannyWindows.binary_child)s");
const TCHAR* kGrrServiceBinaryCommandLine = TEXT("%(NannyWindows.commandline)s");

// A backup binary location, in case the primary binary failed to start.
const TCHAR* kGrrServiceBinaryChildAlternate = TEXT("%(NannyWindows.binary_child_alternate)s");

// The registry value which is updated for each heartbeat. It is a REG_DWORD and
// stores a unix epoch time.
const TCHAR* kGrrServiceHeartbeatTime = TEXT("%(NannyWindows.heartbeat_time)s");

// The registry value which is updated for the nanny messages.
const TCHAR* kGrrServiceNannyMessage = TEXT("%(NannyWindows.nanny_message)s");

// The registry value which is updated for the nanny status.
const TCHAR* kGrrServiceNannyStatus = TEXT("%(NannyWindows.nanny_status)s");

// Configuration of nanny policies.
const struct grr::ControllerConfig kNannyConfig = {
  // Child must stay dead for this many seconds.
  60,  // resurrection_period

  // If we receive no heartbeats from the client in this long, child is killed.
  180,  // unresponsive_kill_period
  60,  // event_log_message_suppression
  0,  // failure_count, not yet used
  1024 * 1024 * 1024,  // client memory limit
};

#endif  // GRR_CLIENT_NANNY_WINDOWS_NANNY_H_
