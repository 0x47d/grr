#!/usr/bin/env python
# Copyright 2010 Google Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Various configuration related things."""


import os
import platform
import re

from M2Crypto import BIO
from M2Crypto import RSA
from M2Crypto import X509

from grr.client import conf as flags

from grr.client import client_keys
from grr.lib import registry


# Client name and version information.
GRR_CLIENT_NAME = %(Client.Name)r
GRR_CLIENT_VERSION = %(GRR.Version_Numeric)s
GRR_CLIENT_BUILDTIME = %(.Build_Time)r

# Network information.
NETWORK_API = 3

# The location URL of the server.
LOCATION = "%(Client.Location)s"

# The GRR client performs some proxy detection. However, it cannot
# handle proxy autoconfig settings. Here, additional proxy servers
# can be given as a list of strings of the form "http://server:port/".
PROXY_SERVERS = []

# Nanny service information.

# TODO(jbmetz): does this comment still apply? Especially the override part.
# Default Windows nanny service name. Override using --service_name flag.
SERVICE_NAME = %(Nanny.Name)r

# TODO(jbmetz): move the log file to the configuration file?
NANNY_LOGFILE = "/var/run/%(Nanny.Log_File_Name)s"
NANNY_STATUS_FILE = "/var/run/(Nanny.Status_File_Name)s"
UNRESPONSIVE_KILL_PERIOD = 60

# Certificates and keys information.
CAMODE = client_keys.CAMODE
CACERTS = client_keys.CACERTS
EXEC_SIGNING_KEY = client_keys.EXEC_SIGNING_KEY
DRIVER_SIGNING_KEY = client_keys.DRIVER_SIGNING_KEY

flags.DEFINE_string(
    "cacert", None, help="The CA certificate we use to verify the server.")

flags.DEFINE_string(
    "camode", client_keys.CAMODE, "The mode to run in, options: test, "
    "production, staging. This affects the CA certificate we trust.")

flags.DEFINE_string("driver_signing_key", None,
                    help="The certificate we use to verify drivers.")

flags.DEFINE_string("exec_signing_key", None,
                    help="The certificate we use to verify executables.")

# Platform specific information.

# The configuration file which is used for POSIX-based systems like Linux or
# Mac OS X.
CONFIG_FILE = "%(ConfigFile.Path_Prefix)s/%(ConfigFile.Name)s"

# The location of the Mac OS X launchctl plist.
LAUNCHCTL_PLIST = "%(Plist.Path)s"

# The Registry key in which the configuratioin is stored for Windows-based
# systems.
REGISTRY_KEY = "%(Registry.Service_Key|escape)s"

if platform.system() == "Windows":
  # The double escaped %% is removed by the config manager.
  LOGFILE_PATH = "%%s/System32/LogFiles/%(Client.Log_File_Name)s" %% (
      os.environ["SystemRoot"])

  flags.DEFINE_string(
      "regpath", REGISTRY_KEY, "A registry path for storing GRR configuration.")
else:
  LOGFILE_PATH = "/tmp/%(Client.Log_File_Name)s"

  flags.DEFINE_string(
      "config", CONFIG_FILE, "Comma separated list of grr configuration files.")


FLAGS = flags.FLAGS


class ConfigInit(registry.InitHook):
  """Update configuration from command line flags."""

  def CheckCert(self, cert_string, label):
    """Checks certificates for validity and tries to fix mangled certifcate
       strings."""
    start_marker = "-----BEGIN CERTIFICATE-----"
    end_marker = "-----END CERTIFICATE-----"

    try:
      X509.load_cert_string(cert_string)
      return cert_string
    except X509.X509Error:
      pass

    # If we arrive here, the certificate might be given as a one line string.
    if (start_marker in cert_string and
        end_marker in cert_string):

      start_cert = cert_string.find(start_marker) + len(start_marker)
      end_cert = cert_string.find(end_marker)
      cert = cert_string[start_cert:end_cert]

      parts = [start_marker]
      parts.append(re.sub("(.{64})", r"\1\n", cert).rstrip())
      parts.append(end_marker)

      new_cert_string = "\n".join(parts)
      try:
        X509.load_cert_string(new_cert_string)
        return new_cert_string
      except X509.X509Error:
        pass

    # The double escaped %% is removed by the config manager.
    raise RuntimeError("Invalid %%s certificate." %% label)

  def CheckKey(self, key_string, label):
    """Checks the keys for validity and tries to fix mangled key strings."""
    start_marker = "-----BEGIN PUBLIC KEY-----"
    end_marker = "-----END PUBLIC KEY-----"

    try:
      bio = BIO.MemoryBuffer(key_string)
      RSA.load_pub_key_bio(bio)
      return key_string
    except RSA.RSAError:
      pass

    # If we arrive here, the key might be given as a one line string.
    if (start_marker in key_string and
        end_marker in key_string):

      start_key = key_string.find(start_marker) + len(start_marker)
      end_key = key_string.find(end_marker)
      key = key_string[start_key:end_key]

      parts = [start_marker]
      parts.append(re.sub("(.{64})", r"\1\n", key).rstrip())
      parts.append(end_marker)

      new_key_string = "\n".join(parts)
      try:
        bio = BIO.MemoryBuffer(new_key_string)
        RSA.load_pub_key_bio(bio)
        return new_key_string
      except RSA.RSAError:
        pass

    # The double escaped %% is removed by the config manager.
    raise RuntimeError("Invalid %%s key." %% label)

  def RunOnce(self):
    """Initializes and validates the certificates."""
    try:
      camode = FLAGS.camode.upper()
    except AttributeError:
      # UI does not use certificates/keys so we return.
      return

    # Allow updating of the certificates from the command line.
    if FLAGS.cacert is not None:
      CACERTS[camode] = FLAGS.cacert

    if FLAGS.exec_signing_key is not None:
      EXEC_SIGNING_KEY[camode] = FLAGS.exec_signing_key

    if FLAGS.driver_signing_key is not None:
      DRIVER_SIGNING_KEY[camode] = FLAGS.driver_signing_key

   # Check for validity.
    CACERTS[camode] = self.CheckCert(
        CACERTS[camode], "CA")
    EXEC_SIGNING_KEY[camode] = self.CheckKey(
        EXEC_SIGNING_KEY[camode], "exec signing")
    DRIVER_SIGNING_KEY[camode] = self.CheckKey(
        DRIVER_SIGNING_KEY[camode], "driver signing")
